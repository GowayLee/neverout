> 软件系统的设计逻辑 
# 24大设计模式和7个原则
***
## 7个原则
***
- 单一职责原则【SINGLE RESPONSIBILITY PRINCIPLE】: 一个类负责一项职责。

- 里氏替换原则【LISKOV SUBSTITUTION PRINCIPLE】: 继承与派生的规则。

- 依赖倒置原则【DEPENDENCE INVERSION PRINCIPLE】: 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。即针对接口编程，不要针对实现编程。

- 接口隔离原则【INTERFACE SEGREGATION PRINCIPLE】: 建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。

- 迪米特法则【LOW OF DEMETER】: 低耦合，高内聚。

- 开闭原则【OPEN CLOSE PRINCIPLE】: 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。

- 组合/聚合复用原则【Composition/Aggregation Reuse Principle(CARP) 】: 尽量使用组合和聚合少使用继承的关系来达到复用的原则。

### 接口隔离原则与迪米特原则的差异

- **接口隔离原则** 关注的是接口的设计，确保每个接口尽量专一，不包含客户端不需要的方法。它的目的是避免因冗长或不相关的接口而导致的复杂性和耦合。
  
- **迪米特原则** 关注的是对象之间的关系，确保一个对象尽可能少地了解和依赖其他对象。它的目的是减少对象之间的耦合，使系统更容易维护和扩展。

## 24大设计模式

---
### 创建型模式（5种）

1. **单例模式（Singleton）**
   - 确保一个类只有一个实例，并提供全局访问点。
2. **工厂方法模式（Factory Method）**
   - 定义一个创建对象的接口，允许子类决定实例化哪个类。
3. **抽象工厂模式（Abstract Factory）**
   - 提供一个接口用于创建一系列相关或依赖的对象，而无需指定它们的具体类。
4. **建造者模式（Builder）**
   - 将一个复杂对象的构建与其表示分离，允许同一个构建过程创建不同的表示。
5. **原型模式（Prototype）**
   - 使用原型实例指定创建对象的类型，并通过复制这些原型创建新的对象。

### 结构型模式（7种）

1. **适配器模式（Adapter）**
   - 允许将一个类的接口转换成客户期望的另一个接口。
2. **桥接模式（Bridge）**
   - 将抽象部分与实现部分分离，使得两者可以独立地变化。
3. **装饰器模式（Decorator）**
   - 动态地给对象添加新的功能，同时又不改变其结构。
4. **外观模式（Facade）**
   - 提供一个统一的接口，用于访问子系统中的一群接口，简化了客户端的接口。
5. **组合模式（Composite）**
   - 允许用户将对象组合成树形结构，以表示部分整体层次结构。
6. **享元模式（Flyweight）**
   - 使用共享技术有效地支持大量细粒度对象的复用。
7. **代理模式（Proxy）**
   - 提供一个代理或占位符来控制对另一个对象的访问。

### 行为型模式（11种）

1. **模板方法模式（Template Method）**
   - 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。
2. **命令模式（Command）**
   - 将一个请求封装为一个对象，从而使您可以用不同的请求对客户进行参数化。
3. **迭代器模式（Iterator）**
   - 提供一种方法来访问聚合对象中各个元素，而又不暴露其内部的表示。
4. **观察者模式（Observer）**
   - 当一个对象变化时，所有依赖于它的对象都会被通知并更新。
5. **中介者模式（Mediator）**
   - 通过一个中介对象封装一系列对象之间的交互，使对象间不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
6. **状态模式（State）**
   - 允许一个对象在其内部状态改变时改变它的行为。
7. **策略模式（Strategy）**
   - 定义一系列的算法，并将每一个算法封装起来，使它们可以相互替换。
8. **责任链模式（Chain of Responsibility）**
   - 为请求创建一个接收者对象的链。
9. **访问者模式（Visitor）**
   - 允许一个或多个操作应用到一系列对象上，解耦操作和对象本身。
10. **备忘录模式（Memento）**
    - 在不破坏封装的条件下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
11. **解释器模式（Interpreter）**
    - 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

# 我们的使用

## 1. 单例模式
